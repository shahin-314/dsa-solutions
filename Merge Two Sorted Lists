

---

## **Code Explanation**

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy;               // 1️⃣ ek temporary dummy node banaya
        ListNode* tail = &dummy;       // 2️⃣ tail pointer dummy ke address pe point kar raha
        
        while (list1 && list2) {       // 3️⃣ jab tak dono lists khatam nahi hote
            if (list1->val < list2->val) {   // 4️⃣ chhota value pick karo
                tail->next = list1;    // tail ka next chhote wale node ko point kare
                list1 = list1->next;   // list1 aage badhao
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;         // tail pointer ko aage le jao
        }
        
        // 5️⃣ jo list bachi hui hai, use tail ke baad attach kar do
        tail->next = list1 ? list1 : list2;

        return dummy.next;             // 6️⃣ dummy ke next se merged list ka head milega
    }
};
```

---

## **Dry Run Example**

**Input**:

```
list1: 1 → 3 → 5
list2: 2 → 4 → 6
```

**Step-by-step:**

1. **Initialization**:

```
dummy → null
tail → dummy
```

2. **Loop start**:

   * Compare `1` and `2` → `1` chhota hai.
   * `tail->next = list1` → dummy → 1
   * `list1 = 3 → 5`
   * `tail = tail->next` → tail ab `1` pe.

```
dummy → 1
         ↑ tail
list1: 3 → 5
list2: 2 → 4 → 6
```

3. Compare `3` and `2` → `2` chhota.

   * `tail->next = list2` → 1 → 2
   * `list2 = 4 → 6`
   * `tail = 2`

```
dummy → 1 → 2
              ↑ tail
list1: 3 → 5
list2: 4 → 6
```

4. Compare `3` and `4` → `3` chhota.

   * `tail->next = list1` → 1 → 2 → 3
   * `list1 = 5`
   * `tail = 3`

5. Compare `5` and `4` → `4` chhota.

   * `tail->next = list2` → 1 → 2 → 3 → 4
   * `list2 = 6`
   * `tail = 4`

6. Compare `5` and `6` → `5` chhota.

   * `tail->next = list1` → 1 → 2 → 3 → 4 → 5
   * `list1 = null`
   * `tail = 5`

7. **Loop end** (kyunki `list1` null ho gaya), attach remaining:

   * `tail->next = list2` (jo `6` hai).

```
Final merged list:
1 → 2 → 3 → 4 → 5 → 6
```

8. Return `dummy.next` → head of merged list (1).

---

## **Why Dummy Node?**

* Dummy node ek **temporary starting point** hai jo merge process ko simple banata hai.
* Isse hume alag se head handle karne ka jhanjhat nahi hota.

---

## **Time Complexity**

* Hum **har ek node ko exactly 1 baar visit** karte hain (ya to `list1` se, ya `list2` se).
* Total nodes = `m + n`
  **Time complexity = O(m + n)**

---

## **Space Complexity**

* Hum sirf **ek dummy node aur kuch pointers** bana rahe hain (no extra array or vector).
* Extra space = **O(1)**
  (list nodes ka space count nahi hota kyunki wo already given hote hain)

---

## **Summary**

* **Dummy node** → easy implementation, no special head handling.
* **Tail pointer** → merged list ke end ko track karta hai.
* **While loop** → sorted merge logic.
* **Attach remainder** → loop ke baad jo bacha hua list hai, usse directly jod do.
* **Time:** O(m+n), **Space:** O(1)

---

Agar tum chaho to mai iska **animation-style diagram** bana ke tumhe step-by-step visuals me samjha sakta hoon, jisme arrows se pura merging process dikhega.
Kya tum chahte ho mai wo bana du?
