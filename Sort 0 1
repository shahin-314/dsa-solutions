--------------------------- CODE -------------------------------------------

#include <bits/stdc++.h>   // (Note: ye GCC specific hai; std code me <algorithm> kaafi hota hai)
using namespace std;

void sortZeroesAndOne(int input[], int size) {
    int left = 0;            // left pointer start se
    int right = size - 1;    // right pointer end se

    // Jab tak left pointer right se chhota hai, kaam chalta rahe
    while (left < right) {

        if (input[left] == 0) {
            // Agar left par 0 hai, to wo already sahi jagah hai (0s left me chahiye)
            // isliye left ko aage badha do
            left++;
        } 
        else if (input[right] == 1) {
            // Agar right par 1 hai, to wo already sahi jagah hai (1s right me chahiye)
            // isliye right ko piche le aao
            right--;
        } 
        else {
            // Yaha tab aayenge jab:
            // input[left] == 1  AND  input[right] == 0
            // Matlab left side me 1 galat hai, right side me 0 galat hai
            // Dono ko swap karke sahi jagah bhej do
            swap(input[left], input[right]);
            // Ab dono pointers ko move karo kyunki dono positions fix ho gayi
            left++;
            right--;
        }
    }
}

------------------------------------------------------------------------------


Perfect ðŸ‘ Letâ€™s take your new example:

`input = [1, 1, 1, 0, 0, 1, 1, 1, 1]`

ðŸ‘‰ Total size = **9**
ðŸ‘‰ Start: `left = 0`, `right = 8`

Now letâ€™s **dry run step by step** ðŸ‘‡

---

### Initial Array

```
[1, 1, 1, 0, 0, 1, 1, 1, 1]
 left=0                     right=8
```

---

### Step 1

* `input[left] = 1`
* `input[right] = 1`
  âž¡ï¸ Condition: `input[right] == 1` â†’ so `right--`

```
[1, 1, 1, 0, 0, 1, 1, 1, 1]
 left=0                 right=7
```

---

### Step 2

* `input[left] = 1`
* `input[right] = 1`
  âž¡ï¸ Again, `input[right] == 1` â†’ `right--`

```
[1, 1, 1, 0, 0, 1, 1, 1, 1]
 left=0             right=6
```

---

### Step 3

* `input[left] = 1`
* `input[right] = 1`
  âž¡ï¸ Same case â†’ `right--`

```
[1, 1, 1, 0, 0, 1, 1, 1, 1]
 left=0         right=5
```

---

### Step 4

* `input[left] = 1`
* `input[right] = 1`
  âž¡ï¸ Same again â†’ `right--`

```
[1, 1, 1, 0, 0, 1, 1, 1, 1]
 left=0     right=4
```

---

### Step 5

* `input[left] = 1`
* `input[right] = 0`
  âž¡ï¸ Else case â†’ **swap(1, 0)**
* After swap:

```
[0, 1, 1, 0, 1, 1, 1, 1, 1]
 left=1     right=3
```

---

### Step 6

* `input[left] = 1`
* `input[right] = 0`
  âž¡ï¸ Else case â†’ **swap(1, 0)**
* After swap:

```
[0, 0, 1, 1, 1, 1, 1, 1, 1]
 left=2     right=2
```

---

### Step 7

Now `left == right` â†’ loop condition `left < right` fails â†’ **stop** âœ…

---

### Final Sorted Array

```
[0, 0, 1, 1, 1, 1, 1, 1, 1]
```

---

## ðŸ§  Key Observation

* Starting me saare right-side ke 1s skip ho gaye (right pointer piche aata raha).
* Jab `left` par galat 1 aur `right` par galat 0 mila â†’ swap kiya.
* Swap karte hi dono numbers correct jagah chale gaye.
* Last me array sorted ban gaya.

---



